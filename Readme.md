## Обзор проекта
Проект представляет собой симулятор битвы армий в реальном времени. Две армии, состоящие из юнитов, сражаются друг с другом с использованием различных свойств (цвет, меш, размер), влияющих на характеристики юнитов.

## Архитектурные цели и решения

### 1. Структурный подход

Проблема: Необходимость управления множеством взаимодействующих объектов (армии, юниты, свойства).
Решение: Четкое разделение на компоненты с определенными обязанностями:

Army - управление коллекцией юнитов
BaseUnit - поведение отдельных юнитов
Property - модификация характеристик
ArmyGenerator - создание и размещение юнитов

### 2. Событийная система (EventsA)

Проблема: Прямые связи между компонентами создают сильную связанность.
Решение: Использование UnityEvent для слабой связанности.
Почему выбрано:
```
// Позволяет компонентам общаться без прямых ссылок
public static class EventsA
{
    public static UnityEvent ArmyDeath = new UnityEvent();
    public static UnityEvent<string> ArmyWin = new UnityEvent<string>();
    public static UnityEvent StartButtle = new UnityEvent();
    public static UnityEvent ChangeProperty = new UnityEvent();
}
```
- Упрощает добавление новых реакций на события
- Облегчает отладку и модификацию
- Позволяет разделить инициирование и обработку событий

### 3. Система свойств на ScriptableObject

Проблема: Необходимость гибкой настройки характеристик юнитов.
Решение: Иерархия ScriptableObject для свойств:

```
public class Property : ScriptableObject  // Базовый класс
public class ColorProperty : Property    // Наследник для цвета
public class MeshProperty : Property     // Наследник для меша
public class SizeProperty : Property     // Наследник для размера
```
Преимущества:
- Редакторская настройка в Unity
- Легкое создание новых типов свойств
- Разделение данных и логики

### 4. Генератор армий как Singleton

Проблема: Необходимость единой точки создания армий.
Решение: Паттерн Singleton для ArmyGenerator:

```
public static ArmyGenerator instance;
public void Awake()
{
    if (instance == null) instance = this;
    else Destroy(gameObject);
}
```
Обоснование: Одна точка контроля за созданием армий упрощает управление и гарантирует единственность генератора.

### 5. Компонентный подход для UI

Проблема: Управление выбором свойств для армий.
Решение: SimpleDropdown загружает свойства из Resources и связывает их с армией
Преимущества:
- Динамическая загрузка всех свойств из папки
- Обработка выбора через события Unity UI
- Поддержка нескольких типов свойств через систему папок

## Ключевые архитектурные паттерны
1. Наблюдатель (Observer)

Через EventsA компоненты подписываются на события без знания об отправителях.

2. Стратегия (Strategy)

Свойства (Property) реализуют стратегию модификации юнитов через виртуальный метод ApplyAdditProperty.

3. Состояние (State)

BaseUnit имеет различные состояния (поиск, движение, атака), управляемые через Update и корутины.

4. Фабричный метод

ArmyGenerator.CreateArmy создает юниты по заданному шаблону сетки.

Поток данных

```
UI Elements → StartBattle → EventsA.StartButtle
    ↓
Army → GenerateArmy → ArmyGenerator
    ↓
BaseUnit создается → ApplyProperty → Property
    ↓
Battle Logic → EventsA.ArmyDeath/ArmyWin → UI (Win Window)
```

## Масштабирование

Проект может быть масштабирован путем:

- Добавления новых типов свойств (наследование от Property)
- Создания различных типов юнитов (наследование от BaseUnit)
- Реализации системы модификаторов
- Добавления системы команд и группировок

## Дополнительная фукнция 
В качестве дополнительной функции используется BattleRage класса BaseUnit. Она вызывается из класса Army и связана со статичным полем BattleRage. Срабатывает один раз за бой у армии, в которой количество юнитов сократилось вдвое.
```
public class Army
{
    public static bool BattleRage = false;
}
public class BaseUnit
{
    public void BattleRage()
    {
        ATK *= 2;
    }
}
```
## Архитектурный подход
Проект не имеет четкого архитектурного подохода, но основной архиетиктурой для ориентирования является MVP c разделением логики от визуальной части. Поэтому в проекте есть различные сочетания:
- Компонентно-ориентированная архитектура - естественная для Unity, где каждый MonoBehaviour отвечает за конкретную функциональность
- Событийно-ориентированная коммуникация через статическую систему EventsA для слабой связанности компонентов
- Data-driven дизайн на ScriptableObject для гибкой настройки свойств юнитов
- Простая структура с разделением данных (Property), логики (BaseUnit, Army) и представления (UI)
Такой подход был выбран как оптимальный баланс между скоростью разработки, поддерживаемостью и возможностью будущего масштабирования без избыточной сложности классических архитектурных паттернов.